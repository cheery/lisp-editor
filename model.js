// Generated by CoffeeScript 1.6.3
(function() {
  var Carriage, ListBuffer, ListNode, TextBuffer, TextNode,
    __slice = [].slice;

  window.hoverColor = "#222";

  window.selectColor = "#888";

  window.selectCompositeOp = "darker";

  window.padding = 8;

  ListNode = (function() {
    function ListNode(list) {
      var item, _i, _len, _ref;
      this.list = list;
      this.type = 'list';
      this.parent = null;
      this.length = this.list.length;
      this.hover = false;
      _ref = this.list;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        item.parent = this;
      }
    }

    ListNode.prototype.copy = function() {
      var item, list, _i, _len, _ref;
      list = [];
      _ref = this.list;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        list.push(item.copy());
      }
      return new ListNode(list);
    };

    ListNode.prototype.yank = function(start, stop) {
      return new ListBuffer(this.list.slice(start, stop), this);
    };

    ListNode.prototype.kill = function(start, stop) {
      var list, _ref;
      list = this.list.slice(start, stop);
      [].splice.apply(this.list, [start, stop - start].concat(_ref = [])), _ref;
      this.length = this.list.length;
      return new ListBuffer(list, null);
    };

    ListNode.prototype.put = function(index, buff) {
      var _ref, _ref1;
      if (buff.type !== "listbuffer") {
        throw "buffer conflict";
      }
      if (buff.link != null) {
        [].splice.apply(this.list, [index, index - index].concat(_ref = buff.list.copy())), _ref;
      } else {
        [].splice.apply(this.list, [index, index - index].concat(_ref1 = buff.list)), _ref1;
      }
      return this.length = this.list.length;
    };

    ListNode.prototype.mousemotion = function(x, y) {
      var childhover, item, _i, _len, _ref;
      x -= this.x;
      y -= this.y;
      childhover = false;
      _ref = this.list;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        childhover = childhover || item.mousemotion(x, y);
      }
      this.hover = ((0 <= x && x < this.width)) && ((0 <= y && y < this.height)) && !childhover;
      return childhover || this.hover;
    };

    ListNode.prototype.layout = function(bc) {
      var item, offset, row, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
      this.x = 0;
      this.y = 0;
      this.width = 0;
      this.height = 0;
      this.rows = [];
      this.rows.push(row = {
        offset: padding,
        offsets: [padding],
        frames: [],
        height: 16
      });
      offset = padding;
      _ref = this.list;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        item.layout(bc);
        if (item.type === 'cr') {
          this.rows.push(row = {
            offset: row.offset + row.height + padding,
            offsets: [padding],
            frames: [],
            height: 16
          });
          this.width = Math.max(offset, this.width);
          this.height = Math.max(row.offset + row.height + 2 * padding, this.height);
          offset = padding;
        } else {
          item.x = offset;
          item.y = row.offset;
          offset += padding + item.width;
          row.offsets.push(offset);
          row.frames.push(item);
          row.height = Math.max(row.height, item.height);
        }
      }
      this.width = Math.max(offset, this.width);
      this.height = Math.max(row.offset + row.height + padding, this.height);
      _ref1 = this.rows;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        row = _ref1[_j];
        _ref2 = row.frames;
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          item = _ref2[_k];
          item.y += row.height / 2 - item.height / 2;
        }
      }
      if (this.rows.length > 1) {
        this.width += padding;
      }
      if (this.rows.length > 1) {
        return this.height += padding;
      }
    };

    ListNode.prototype.draw = function(bc) {
      var item, row, _i, _len, _ref;
      bc.fillStyle = "white";
      bc.strokeStyle = "black";
      if (this.hover) {
        bc.strokeStyle = hoverColor;
      }
      bc.fillRect(this.x, this.y, this.width, this.height);
      bc.strokeRect(this.x, this.y, this.width, this.height);
      bc.save();
      bc.translate(this.x, this.y);
      _ref = this.list;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        item.draw(bc);
      }
      if (this.selection) {
        row = this.rows[this.selection.row];
        bc.fillStyle = selectColor;
        bc.globalCompositeOperation = selectCompositeOp;
        bc.fillRect(this.selection.left, row.offset, this.selection.right - this.selection.left, row.height);
        bc.globalCompositeOperation = "source-over";
      }
      return bc.restore();
    };

    return ListNode;

  })();

  TextNode = (function() {
    function TextNode(text) {
      this.text = text;
      this.type = 'text';
      this.parent = null;
      this.hover = false;
      this.length = this.text.length;
    }

    TextNode.prototype.copy = function() {
      return new TextNode(this.text);
    };

    TextNode.prototype.yank = function(start, stop) {
      return new TextBuffer(this.text.slice(start, stop), this);
    };

    TextNode.prototype.kill = function(start, stop) {
      var text, _ref;
      text = this.text.slice(start, stop);
      [].splice.apply(this.text, [start, stop - start].concat(_ref = [])), _ref;
      this.length = this.text.length;
      return new TextBuffer(text, null);
    };

    TextNode.prototype.put = function(index, buff) {
      if (buff.type !== "textbuffer") {
        throw "buffer conflict";
      }
      this.text = this.text.slice(0, index) + buff.text + this.text.slice(index);
      return this.length = this.text.length;
    };

    TextNode.prototype.layout = function(bc) {
      bc.font = "16px sans-serif";
      this.x = 0;
      this.y = 0;
      this.width = bc.measureText(this.text).width;
      return this.height = 16;
    };

    TextNode.prototype.mousemotion = function(x, y) {
      return this.hover = ((this.x <= x && x < this.x + this.width)) && ((this.y <= y && y < this.y + this.height));
    };

    TextNode.prototype.draw = function(bc) {
      bc.font = "16px sans-serif";
      bc.fillStyle = "black";
      if (this.hover) {
        bc.fillStyle = hoverColor;
      }
      bc.fillText(this.text, this.x, this.y + this.height / 2, this.width);
      if (this.selection) {
        bc.fillStyle = selectColor;
        bc.globalCompositeOperation = selectCompositeOp;
        bc.fillRect(this.x + this.selection.left, this.y, this.selection.right - this.selection.left, this.height);
        return bc.globalCompositeOperation = "source-over";
      }
    };

    return TextNode;

  })();

  Carriage = (function() {
    function Carriage(list) {
      this.list = list;
      this.type = 'cr';
    }

    Carriage.prototype.mousemotion = function(x, y) {
      return false;
    };

    Carriage.prototype.layout = function(bc) {
      this.x = 0;
      this.y = 0;
      this.height = 0;
      return this.width = 0;
    };

    Carriage.prototype.draw = function(bc) {};

    return Carriage;

  })();

  ListBuffer = (function() {
    function ListBuffer(list, link) {
      this.list = list;
      this.link = link;
      this.type = "listbuffer";
    }

    return ListBuffer;

  })();

  TextBuffer = (function() {
    function TextBuffer(text, link) {
      this.text = text;
      this.link = link;
      this.type = "textbuffer";
    }

    return TextBuffer;

  })();

  window.cr = function() {
    return new Carriage();
  };

  window.text = function(text) {
    return new TextNode(text);
  };

  window.list = function() {
    var data;
    data = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return new ListNode(data);
  };

  window.listbuffer = function() {
    var list;
    list = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return new ListBuffer(list, null);
  };

  window.textbuffer = function(text) {
    return new TextBuffer(text, null);
  };

}).call(this);
