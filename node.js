// Generated by CoffeeScript 1.6.3
(function() {
  var ListNode, MarkNode, TextNode,
    __slice = [].slice;

  ListNode = (function() {
    function ListNode(list, label) {
      var node, _i, _len, _ref;
      this.list = list;
      this.label = label;
      this.parent = null;
      this.length = this.list.length;
      _ref = this.list;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        node = _ref[_i];
        node.parent = this;
      }
    }

    ListNode.prototype.getRoot = function() {
      if (typeof this.parent === "function" ? this.parent(this.parent.getRoot()) : void 0) {

      } else {
        return this;
      }
    };

    ListNode.prototype.copy = function() {
      var node;
      return newList((function() {
        var _i, _len, _ref, _results;
        _ref = this.list;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          node = _ref[_i];
          _results.push(node.copy());
        }
        return _results;
      }).call(this), this.label);
    };

    ListNode.prototype.yank = function(start, stop) {
      var node;
      return newList((function() {
        var _i, _len, _ref, _results;
        _ref = this.list.slice(start, stop);
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          node = _ref[_i];
          _results.push(node.copy());
        }
        return _results;
      }).call(this));
    };

    ListNode.prototype.kill = function(start, stop) {
      var list, node, _i, _len, _ref;
      list = this.list.slice(start, stop);
      [].splice.apply(this.list, [start, stop - start].concat(_ref = [])), _ref;
      this.length = this.list.length;
      for (_i = 0, _len = list.length; _i < _len; _i++) {
        node = list[_i];
        node.parent = null;
      }
      this.changed();
      return newList(list);
    };

    ListNode.prototype.put = function(index, list, copy) {
      var node, _i, _len;
      if (copy == null) {
        copy = true;
      }
      if (!isList(list)) {
        return false;
      }
      list = list.list;
      if (copy) {
        list = (function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = list.length; _i < _len; _i++) {
            node = list[_i];
            _results.push(node.copy());
          }
          return _results;
        })();
      }
      for (_i = 0, _len = list.length; _i < _len; _i++) {
        node = list[_i];
        node.parent = this;
      }
      [].splice.apply(this.list, [index, index - index].concat(list)), list;
      this.length = this.list.length;
      this.changed();
      return true;
    };

    ListNode.prototype.indexOf = function(node) {
      return this.list.indexOf(node);
    };

    ListNode.prototype.slice = function() {
      var args, _ref;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return (_ref = this.list).slice.apply(_ref, args);
    };

    ListNode.prototype.relabel = function(label) {
      this.label = label;
      return this.changed();
    };

    ListNode.prototype.changed = function() {
      var document;
      document = this.getRoot().document;
      if (document != null) {
        return document.wasChanged(this);
      }
    };

    return ListNode;

  })();

  TextNode = (function() {
    function TextNode(text, label) {
      this.text = text;
      this.label = label;
      this.parent = null;
      this.length = this.text.length;
    }

    TextNode.prototype.getRoot = function() {
      if (typeof this.parent === "function" ? this.parent(this.parent.getRoot()) : void 0) {

      } else {
        return this;
      }
    };

    TextNode.prototype.copy = function() {
      return newText(this.text, this.label);
    };

    TextNode.prototype.yank = function(start, stop) {
      return newText(this.text.slice(start, stop));
    };

    TextNode.prototype.kill = function(start, stop) {
      var text;
      text = this.text.slice(start, stop);
      this.text = this.text.slice(0, start) + this.text.slice(stop);
      this.length = this.text.length;
      this.changed();
      return newText(text);
    };

    TextNode.prototype.put = function(index, node, copy) {
      if (copy == null) {
        copy = true;
      }
      if (!isText(node)) {
        return false;
      }
      this.text = this.text.slice(0, index) + node.text + this.text.slice(index);
      this.length = this.text.length;
      this.changed();
      return true;
    };

    TextNode.prototype.slice = function() {
      var args, _ref;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return (_ref = this.list).slice.apply(_ref, args);
    };

    TextNode.prototype.relabel = function(label) {
      this.label = label;
      return this.changed();
    };

    TextNode.prototype.changed = function() {
      var document;
      document = this.getRoot().document;
      if (document != null) {
        return document.wasChanged(this);
      }
    };

    return TextNode;

  })();

  MarkNode = (function() {
    function MarkNode(label) {
      this.label = label;
      this.parent = null;
    }

    MarkNode.prototype.copy = function() {
      return newMark(this.label);
    };

    MarkNode.prototype.relabel = function(label) {
      this.label = label;
      return this.changed();
    };

    MarkNode.prototype.changed = function() {
      var document;
      document = this.getRoot().document;
      if (document != null) {
        return document.wasChanged(this);
      }
    };

    return MarkNode;

  })();

  window.newList = function(list, label) {
    if (label == null) {
      label = null;
    }
    return new ListNode(list, label);
  };

  window.newText = function(text, label) {
    if (label == null) {
      label = null;
    }
    return new TextNode(text, label);
  };

  window.newMark = function(label) {
    if (label == null) {
      label = null;
    }
    return new MarkNode(label);
  };

  window.isList = function(node, label) {
    return node instanceof ListNode && isLabelled(node, label);
  };

  window.isText = function(node, label) {
    return node instanceof TextNode && isLabelled(node, label);
  };

  window.isMark = function(node, label) {
    return node instanceof MarkNode && isLabelled(node, label);
  };

  window.isLabelled = function(node, label) {
    if (label != null) {
      return node.label === label;
    } else {
      return true;
    }
  };

}).call(this);
