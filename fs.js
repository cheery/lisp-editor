// Generated by CoffeeScript 1.6.3
(function() {
  var Document;

  if (window.requestFileSystem == null) {
    window.requestFileSystem = window.webkitRequestFileSystem;
  }

  window.LispFS = (function() {
    function LispFS(callback) {
      var _this = this;
      this.entries = [];
      requestFileSystem(PERSISTENT, 1024 * 1024, function(fs) {
        _this.fs = fs;
        _this.running = true;
        _this.updateList();
        if (callback != null) {
          return callback();
        }
      });
      this.documents = [];
    }

    LispFS.prototype.updateList = function() {
      var ls,
        _this = this;
      ls = this.fs.root.createReader();
      return ls.readEntries(function(entries) {
        _this.entries = entries;
      });
    };

    LispFS.prototype.load = function(path, callback) {
      var failure, success,
        _this = this;
      failure = function(error) {
        var doc, _i, _len, _ref;
        _ref = _this.documents;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          doc = _ref[_i];
          if (doc.ent != null) {
            continue;
          }
          if (path === doc.name) {
            return callback(doc);
          }
        }
        _this.documents.push(doc = new Document(null, path, list()));
        return callback(doc);
      };
      success = function(ent) {
        var doc, readFile, _i, _len, _ref;
        _ref = _this.documents;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          doc = _ref[_i];
          if (doc.ent == null) {
            continue;
          }
          if (ent.fullPath === doc.ent.fullPath) {
            return callback(doc);
          }
        }
        readFile = function(file) {
          var reader;
          reader = new FileReader();
          reader.onload = function() {
            var e, node;
            try {
              node = importJson(JSON.parse(reader.result));
            } catch (_error) {
              e = _error;
              console.log("error at read: " + e);
              node = list();
            }
            _this.documents.push(doc = new Document(ent, path, node));
            return callback(doc);
          };
          return reader.readAsText(file);
        };
        return ent.file(readFile, failure);
      };
      return this.fs.root.getFile(path, {}, success, failure);
    };

    LispFS.prototype.store = function(doc, callback) {
      var success, writeToFile,
        _this = this;
      writeToFile = function(ent) {
        return ent.createWriter(function(writer) {
          writer.truncate(0);
          return ent.createWriter(function(writer) {
            var blob, data;
            writer.onwriteend = function() {
              doc.wasSaved();
              _this.updateList();
              if (callback != null) {
                return callback();
              }
            };
            data = JSON.stringify(exportJson(doc.node));
            blob = new Blob([data], {
              type: "text/plain"
            });
            return writer.write(blob);
          });
        });
      };
      if (doc.ent != null) {
        return writeToFile(doc.ent);
      } else {
        success = function(ent) {
          return writeToFile(doc.ent = ent);
        };
        return this.fs.root.getFile(doc.name, {
          create: true
        }, success);
      }
    };

    return LispFS;

  })();

  Document = (function() {
    function Document(ent, name, node) {
      this.ent = ent;
      this.name = name;
      this.node = node;
      this.node.document = this;
      this.lastsave = Date.now() / 1000;
      this.lastchange = Date.now() / 1000;
    }

    Document.prototype.replace = function(node) {
      this.node = node;
      return this.node.document = this;
    };

    Document.prototype.isModified = function() {
      return this.lastsave < this.lastchange;
    };

    Document.prototype.wasSaved = function() {
      return this.lastsave = Date.now() / 1000;
    };

    Document.prototype.wasChanged = function() {
      console.log('was changed!');
      return this.lastchange = Date.now() / 1000;
    };

    return Document;

  })();

}).call(this);
